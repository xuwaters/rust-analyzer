(function() {
    var type_impls = Object.fromEntries([["hir_ty",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Clone-for-Solution%3CI%3E\" class=\"impl\"><a href=\"#impl-Clone-for-Solution%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.82.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a> for Solution&lt;I&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.82.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a> + Interner,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone\" class=\"method trait-impl\"><a href=\"#method.clone\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.82.0/core/clone/trait.Clone.html#tymethod.clone\" class=\"fn\">clone</a>(&amp;self) -&gt; Solution&lt;I&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href=\"https://doc.rust-lang.org/1.82.0/core/clone/trait.Clone.html#tymethod.clone\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.82.0/src/core/clone.rs.html#174\">source</a></span><a href=\"#method.clone_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.82.0/core/clone/trait.Clone.html#method.clone_from\" class=\"fn\">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href=\"https://doc.rust-lang.org/1.82.0/core/clone/trait.Clone.html#method.clone_from\">Read more</a></div></details></div></details>","Clone","hir_ty::Solution"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-Solution%3CI%3E\" class=\"impl\"><a href=\"#impl-Debug-for-Solution%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.82.0/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> for Solution&lt;I&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.82.0/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> + Interner,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.82.0/core/fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/1.82.0/core/fmt/struct.Formatter.html\" title=\"struct core::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.82.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/1.82.0/core/fmt/struct.Error.html\" title=\"struct core::fmt::Error\">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href=\"https://doc.rust-lang.org/1.82.0/core/fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details>","Debug","hir_ty::Solution"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-HasInterner-for-Solution%3CI%3E\" class=\"impl\"><a href=\"#impl-HasInterner-for-Solution%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; HasInterner for Solution&lt;I&gt;<div class=\"where\">where\n    I: Interner,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Interner\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Interner\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Interner</a> = I</h4></section></summary><div class='docblock'>The interner associated with the type.</div></details></div></details>","HasInterner","hir_ty::Solution"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq-for-Solution%3CI%3E\" class=\"impl\"><a href=\"#impl-PartialEq-for-Solution%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.82.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a> for Solution&lt;I&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.82.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a> + Interner,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a href=\"#method.eq\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.82.0/core/cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;Solution&lt;I&gt;) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.82.0/src/core/cmp.rs.html#261\">source</a></span><a href=\"#method.ne\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.82.0/core/cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,\nand should not be overridden without very good reason.</div></details></div></details>","PartialEq","hir_ty::Solution"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Solution%3CI%3E\" class=\"impl\"><a href=\"#impl-Solution%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; Solution&lt;I&gt;<div class=\"where\">where\n    I: Interner,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.combine\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">combine</a>(self, other: Solution&lt;I&gt;, interner: I) -&gt; Solution&lt;I&gt;</h4></section></summary><div class=\"docblock\"><p>There are multiple candidate solutions, which may or may not agree on\nthe values for existential variables; attempt to combine them. This\noperation does not depend on the order of its arguments.</p>\n<p>This actually isn’t as precise as it could be, in two ways:</p>\n<p>a. It might be that while there are multiple distinct candidates, they\nall agree about <em>some things</em>. To be maximally precise, we would\ncompute the intersection of what they agree on. It’s not clear though\nthat this is actually what we want Rust’s inference to do, and it’s\ncertainly not what it does today.</p>\n<p>b. There might also be an ambiguous candidate and a successful candidate,\nboth with the same refined-goal. In that case, we could probably claim\nsuccess, since if the conditions of the ambiguous candidate were met,\nwe know the success would apply.  Example: <code>?0: Clone</code> yields ambiguous\ncandidate <code>Option&lt;?0&gt;: Clone</code> and successful candidate <code>Option&lt;?0&gt;:    Clone</code>.</p>\n<p>But you get the idea.</p>\n</div></details><section id=\"method.is_trivial_and_always_true\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">is_trivial_and_always_true</a>(&amp;self, interner: I) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.bool.html\">bool</a></h4></section><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_guidance\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">into_guidance</a>(self) -&gt; Guidance&lt;I&gt;</h4></section></summary><div class=\"docblock\"><p>View this solution purely in terms of type inference guidance</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.constrained_subst\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">constrained_subst</a>(\n    &amp;self,\n    interner: I,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.82.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;Canonical&lt;ConstrainedSubst&lt;I&gt;&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Extract a constrained substitution from this solution, even if ambiguous.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.definite_subst\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">definite_subst</a>(\n    &amp;self,\n    interner: I,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.82.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;Canonical&lt;ConstrainedSubst&lt;I&gt;&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Determine whether this solution contains type information that <em>must</em>\nhold, and returns the subst in that case.</p>\n</div></details><section id=\"method.is_unique\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">is_unique</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.bool.html\">bool</a></h4></section><section id=\"method.is_ambig\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">is_ambig</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.82.0/std/primitive.bool.html\">bool</a></h4></section><section id=\"method.display\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">display</a>(&amp;self, interner: I) -&gt; SolutionDisplay&lt;'_, I&gt;</h4></section></div></details>",0,"hir_ty::Solution"],["<section id=\"impl-Eq-for-Solution%3CI%3E\" class=\"impl\"><a href=\"#impl-Eq-for-Solution%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.82.0/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> for Solution&lt;I&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.82.0/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + Interner,</div></h3></section>","Eq","hir_ty::Solution"],["<section id=\"impl-StructuralPartialEq-for-Solution%3CI%3E\" class=\"impl\"><a href=\"#impl-StructuralPartialEq-for-Solution%3CI%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;I&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.82.0/core/marker/trait.StructuralPartialEq.html\" title=\"trait core::marker::StructuralPartialEq\">StructuralPartialEq</a> for Solution&lt;I&gt;<div class=\"where\">where\n    I: Interner,</div></h3></section>","StructuralPartialEq","hir_ty::Solution"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[11907]}