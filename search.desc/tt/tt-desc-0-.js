searchState.loadedDescShard("tt", 0, "<code>tt</code> crate defines a <code>TokenTree</code> data structure: this is the …\nThe token cannot join with the following token to form a …\nIdentifier or keyword.\nThe token can join with the following token to form a …\nThe token can join with the following token to form a …\nIndicates whether a token can join with the following …\nA range in text, represented as a pair of <code>TextSize</code>.\nA measure of text length. Also, equivalently, an index …\nA simple line string used for debugging\nCreate a new <code>TextRange</code> with the given <code>offset</code> and <code>len</code> (…\nStateful iteration over token trees.\nAdd an offset to this range.\nChecked addition. Returns <code>None</code> if overflow occurred.\nSubtract an offset from this range.\nChecked subtraction. Returns <code>None</code> if overflow occurred.\nCheck if this range contains an offset.\nCheck if this range contains an offset.\nCheck if this range completely contains another range.\nCount the number of tokens recursively\nExtends the range to cover <code>other</code> as well.\nExtends the range to cover <code>other</code> offsets as well.\nCreate a zero-length range at the specified offset (…\nThe end point of this range.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe range covered by both ranges, if it exists. If the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this range is empty.\nA “Parser” structure for token trees. We use this when …\nThe size of this range.\nCreates a new <code>TextRange</code> with the given <code>start</code> and <code>end</code> (…\nCreates a new instance of <code>TextSize</code> from a raw <code>u32</code>.\nThe text size of some primitive text-like object.\nRelative order of the two ranges (overlapping ranges are …\nThis is slow, and should be avoided, as it will always …\nThe start point of this range.\nCreate a range up to the given end (<code>..end</code>).\nA safe version of <code>Cursor</code> from <code>syn</code> crate …\nA token tree buffer The safe version of <code>syn</code> <code>TokenBuffer</code>\nCreates a cursor referencing the first token in the buffer …\nBump the cursor\nBump the cursor, if it is a subtree, returns a cursor into …\nIf the cursor is pointing at the end of a subtree, returns …\nCheck whether it is eof\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck whether it is a top level\nIf the cursor is pointing at a <code>Subtree</code>, returns a cursor …\nIf the cursor is pointing at a <code>TokenTree</code>, returns it\nReturns consecutive <code>Punct</code>s that can be glued together.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")